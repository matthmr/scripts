#!/usr/bin/sh

case $1 in
  '--help'|'-h')
    echo "Usage:       uhandle [OPTIONS] URI/FILE"

    echo "Description: Opens a URI/FILE given a handler for its type"
    echo "Options:
  -p: ignore URI parameters
  -f: fork children, exit main handler. cannot be used with \`-d'
  -d: use URI2FILE for fetchables URIs
  -i: run interactively"
    exit 0;;
esac

#### DEFAULTS

BROWSER=w3m
PAGER=less
EDITOR=emacsc
AUDIOPLAYER=mpv
VIDEOPLAYER=mpv

FETCHURL='curl -Ls'
IMGVIEW=feh
GIFVIEW=mpv
PDFVIEW=zathura
DEC=dec

# HIGHLIGHT [URI]
function HIGHLIGHT {
  local uri=$1

  highlight --force=text -O ansi "$uri" | $PAGER
}

#### CMDLINE PARSER

int=false
fork=false
ignore_params=false
remote_uri=false
ignore_uri=false

ignore_params_def='n'
local_def='n'
fork_def='n'
override_def='n'

handler=handle_def_remote
job=""
uri=""
ccmd=""

for arg in $@; do
  case $arg in
    '-d') handler=handle_def_local; local_def='y' ;;
    '-i') int=true ;;
    '-p') ignore_params=true; ignore_params_def='y' ;;
    '-f') fork=true; fork_def='y' ;;
    *) uri=$arg ;;
  esac
done

if [[ -z $uri ]]; then
  echo "E: Missing URI or FILE"
  exit 1
fi

# TODO: support more protocols
if [[ $uri =~ ^https?:// ]]; then
  remote_uri=true
else
  handler=handle_def_local
  local_def='y'
fi

#### FUNCTIONS

# ignoreuriparam URI
function ignoreuriparam {
  local uri=$1
  echo ${uri%%\?*}
}

# mktmpuri URI
function mktmpuri {
  local uri=$1
  echo /tmp/uri-$(echo "$uri" | md5sum | cut -d' ' -f1)
}

# fetch_into_local URI
function fetch_into_local {
  local uri=$1
  rm /tmp/.uri 2>/dev/null

  # tmp_uri=$(mktmpuri $uri)
  eval $FETCHURL $uri > /tmp/.uri # $tmp_uri

  echo /tmp/.uri
}

# prompt_for_handler
function prompt_for_handler {
  echo -n "----------------------------------------
[OPTIONS] [CMDLINE]
Options (uppercase sets it to false):
  -pP: ignore URI params: $ignore_params_def
  -dD: fetch locally (URI only): $local_def
  -fF: fork: $fork_def
  -,: use \`,' as a substitute for the file name
> "
  read cmd
  echo "----------------------------------------"

  if [[ ! -z $cmd ]]; then
    # iterate every character and set each option accordingly
    if [[ $cmd =~ ^- ]]; then
      local cmd_opt="$(echo -n $cmd | grep -Eo '^ *-[pdfPDF,]+')"
      local len="${#cmd_opt}"

      cmd="$(echo -n $cmd | sed -E 's/^ *-[pdfPDF,]+ *//')"

      for (( i = 1; i < len; i++)); do
        local c="${cmd_opt:$i:1}"

        case $c in
          'p') ignore_params=true;;
          'd') handler=handle_def_local;;
          'f') fork=true;;

          'P') ignore_params=false;;
          'D') handler=handle_def_remote;;
          'F') fork=false;;

          ',') ignore_uri=true;;

          *) echo "E: unknown option"; exit 1;;
        esac
      done
    fi

    # empty command means handle with defaults
    ccmd="$cmd"
  fi
}

# handle_def_local URI JOB
function handle_def_local {
  local uri="$1"
  local job="${@:2}"

  case $uri in
    *.pgp) $DEC $uri | HIGHLIGHT; return 0 ;;
  esac

  case "$(file --dereference --brief --mime-type -- "$uri")" in
    image/gif) $job $GIFVIEW $uri ;;
    image/*) $job $IMGVIEW $uri ;;
    video/*) $job $VIDEOPLAYER $uri ;;
    audio/* | application/octet-stream) $AUDIOPLAYER $uri ;;
    # this only works if the program runs in a terminal
    text/html) $BROWSER $uri ;;
    */pdf) $job $PDFVIEW $uri ;;
    *) HIGHLIGHT $uri;;
  esac
}

# handle_def_remote URI JOB
function handle_def_remote {
  local uri="$1"
  local job="${@:2}"

  case $uri in
    *.png|*.jpg|*.jpeg|*.webp|*.bmp) $job $IMGVIEW $uri ;;
    *.mp4|*.mkv|*.mov|*.webm|*.gif) $job $VIDEOPLAYER $uri ;;
    *.ogg|*.mp3) $AUDIOPLAYER $uri ;;
    *.html) $BROWSER $uri ;;
    *.pdf) $job $PDFVIEW $uri ;;
    *) $BROWSER $uri ;;
  esac
}

#### MAIN

# prompt interactively
if $int; then
  prompt_for_handler
fi

# handle remote URI
if $remote_uri; then
  if $ignore_params; then
    uri=$(ignoreuriparam $uri)
  fi

  if [[ $handler == "handle_def_local" ]]; then
    uri=$(fetch_into_local $uri)
  fi
fi

if $fork; then
  job="setsid -f "
fi

# job
#   fork-if: !(as == local && remote_uri): we cannot fork if we have a local
#   file, because we immediately remove it in the end
# while [[ $as != 'local' || $remote_uri != 'true' ]]; do
#   # we'd have to call `wait' anyway, might as well not even fork at all
#   if [[ $remote_uri == 'true' && $handler == 'handle_def_local' ]]; then
#     break
#   fi
#   if $fork; then
#     job=" &"
#   fi
#   break
# done

if [[ ! -z $ccmd ]]; then
  handler="$ccmd"

  if $ignore_uri; then
    sub_uri="s!( ,|^,)( |$)! $uri !"
    handler="$(echo -n "$ccmd" | sed -E "$sub_uri")"
    uri=""
  fi
fi

[[ -z "$job" ]] && job_st="fg" || job_st="bg"

if [[ -z "$ccmd" ]]; then
  echo "I: default: $uri ($job_st)"
  $handler "$uri" $job
else
  echo "I: custom: $handler $uri ($job_st)"
  $job $handler "$uri"
fi
